# -*- coding: utf-8 -*-
"""Ryan_Garcia_HW2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eLJeKGauV7sm1DEvDk5senf3FExGbpQW
"""

#Ryan Garcia Homework 2
#CPSC 4820
import scipy
import numpy as np
import math
import pandas as pd
import cv2  
from google.colab.patches import cv2_imshow
from skimage import io
from PIL import Image 
import matplotlib.pylab as plt
import random

#1-1
F = cv2.imread('kittens.jpg', cv2.IMREAD_COLOR)
cv2_imshow(F)
FG =cv2.cvtColor(F, cv2.COLOR_BGR2GRAY)
cv2_imshow(FG)

#1-2
ret, thresh1 = cv2.threshold(FG, 50, 0, cv2.THRESH_TOZERO)
ret, thresh2 = cv2.threshold(FG, 200, 255, cv2.THRESH_BINARY)

cv2_imshow(thresh1)
cv2_imshow(thresh2)

#1-3
ret, thresh3 = cv2.threshold(FG, 50, 255, cv2.THRESH_BINARY)
ret, thresh4 = cv2.threshold(FG, 200, 0, cv2.THRESH_TOZERO)
cv2_imshow(thresh3)
cv2_imshow(thresh4)

#1-4
print("1-4")
print()
G1 = 1/9*np.ones([ 3, 3])
G2 = 1/100 * np.ones([ 10, 10])
G3 = np.array([[1,2.5,1],
               [0, 0, 0],
               [-1, -2.5, -1]])
G4 = np.array([[1,0,-1],
               [2.5, 0, -2.5],
               [1, 0, -1]])
G5 = np.zeros([5, 5])
sigma = 2
for i in range(0,4):
    for j in range(0, 4):
        G5[i, j] = (((1)/(2*np.pi*sigma**2))*np.exp((i**2+j**2)/(2*sigma**2)))

G6 = np.zeros([5,5])
sigma2 = 2
for i in range(0,4):
    for j in range(0,4):
      G6[i, j] = (((i**2 + j **2)/(sigma2**4))-((2)/sigma2**2))


output = cv2.filter2D(FG, 2, G1)
output2 = cv2.filter2D(FG, 2, G2)
output3 = cv2.filter2D(FG, 2, G3)
output4 = cv2.filter2D(FG, 2, G4)
output5 = cv2.filter2D(FG, 2, G5)
output6 = cv2.filter2D(FG, 2, G6)
print("Image G1")
cv2_imshow(output)
print("Image G2")
cv2_imshow(output2)
print("Image G3")
cv2_imshow(output3)
print("Image G4")
cv2_imshow(output4)
print("Image G5")
cv2_imshow(output5)
print("Image G6")
cv2_imshow(output6)

R = cv2.imread('rally.jpg', cv2.IMREAD_COLOR)
cv2_imshow(R)
print()
RG =cv2.cvtColor(R, cv2.COLOR_BGR2GRAY)
cv2_imshow(RG)

#a
# Generate Gaussian noise using numpy [or random]
gauss = np.random.normal(0,1,RG.size)
gauss = gauss.reshape(RG.shape[0],RG.shape[1])
# Multiply noise to image pixel values
Noisy_image = RG + RG * gauss
#cv2_imshow(Noisy_image)

img = cv2.GaussianBlur(Noisy_image, (3,3), 2)
sobelx = cv2.Sobel(img, cv2.CV_64F, 1, 0, ksize = 5)
sobely = cv2.Sobel(img, cv2.CV_64F, 0, 1, ksize = 5)
median = np.float32(Noisy_image)
# Apply Laplacian operator in some higher datatype
laplacian = cv2.Laplacian(Noisy_image,cv2.CV_64F)


plt.subplot(2,2, 1), plt.imshow(sobelx, cmap = 'gray')
plt.title("Sobel X"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 2), plt.imshow(sobely, cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 3), plt.imshow(laplacian, cmap = 'gray')
plt.title("LoG"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 4), plt.imshow(img, cmap = 'gray')
plt.title("Gaussian Blur"), plt.xticks([]), plt.yticks([])
plt.plot(2,2,1), plt.imshow(median, cmap = 'gray')
plt.title("Median"), plt.xticks([]), plt.yticks([])
plt.show()

#b
snp = (np.copy(RG))
rate = .15
num_s = np.ceil(rate * RG.size)
coords = [np.random.randint(0,i-1,int(num_s))
       for i in RG.shape]
snp[coords] = 0
#Pepper
num_p = np.ceil(rate * RG.size)
coords = [np.random.randint(0,i-1,int(num_p))
       for i in RG.shape]
snp[coords] = 1
#cv2_imshow(snp)

img = cv2.GaussianBlur(snp, (3,3), 2)
sobelx = cv2.Sobel(snp, cv2.CV_64F, 1, 0, ksize = 5)
sobely = cv2.Sobel(snp, cv2.CV_64F, 0, 1, ksize = 5)
median = np.float32(snp)
# Apply Laplacian operator in some higher datatype
laplacian = cv2.Laplacian(snp,cv2.CV_64F)


plt.subplot(2,2, 1), plt.imshow(sobelx, cmap = 'gray')
plt.title("Sobel X"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 2), plt.imshow(sobely, cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 3), plt.imshow(laplacian, cmap = 'gray')
plt.title("LoG"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 4), plt.imshow(img, cmap = 'gray')
plt.title("Gaussian Blur"), plt.xticks([]), plt.yticks([])
plt.plot(2,2,1), plt.imshow(median + img, cmap = 'gray')
plt.title("Median + Gaussian Blur"), plt.xticks([]), plt.yticks([])
plt.show()

#c
#Poisson Noise using random
Noisy_image4 = np.random.poisson(RG / 255.0 * .7) / .7 * 255
cv2_imshow(Noisy_image4)
img = cv2.GaussianBlur(Noisy_image4, (3,3), 2)
sobelx = cv2.Sobel(Noisy_image4, cv2.CV_64F, 1, 0, ksize = 5)
sobely = cv2.Sobel(Noisy_image4, cv2.CV_64F, 0, 1, ksize = 5)
median = np.float32(Noisy_image4)
# Apply Laplacian operator in some higher datatype
laplacian = cv2.Laplacian(Noisy_image4,cv2.CV_64F)


plt.subplot(2,2, 1), plt.imshow(sobelx, cmap = 'gray')
plt.title("Sobel X"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 2), plt.imshow(sobely, cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 3), plt.imshow(laplacian, cmap = 'gray')
plt.title("LoG"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 4), plt.imshow(img, cmap = 'gray')
plt.title("Gaussian Blur"), plt.xticks([]), plt.yticks([])
plt.plot(2,2,1), plt.imshow(median, cmap = 'gray')
plt.title("Median"), plt.xticks([]), plt.yticks([])
plt.show()

#d
gauss = np.random.normal(0,1,RG.size)
gauss = gauss.reshape(RG.shape[0],RG.shape[1])
# Multiply noise to image pixel values
Noisy_image1 = RG + RG * gauss
Noisy_image2 = Noisy_image + RG + Noisy_image1
#cv2_imshow(Noisy_image2)

img = cv2.GaussianBlur(Noisy_image2, (3,3), 2)
sobelx = cv2.Sobel(Noisy_image2, cv2.CV_64F, 1, 0, ksize = 5)
sobely = cv2.Sobel(Noisy_image2, cv2.CV_64F, 0, 1, ksize = 5)
median = np.float32(Noisy_image2)
# Apply Laplacian operator in some higher datatype
laplacian = cv2.Laplacian(Noisy_image2,cv2.CV_64F)


plt.subplot(2,2, 1), plt.imshow(sobelx, cmap = 'gray')
plt.title("Sobel X"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 2), plt.imshow(sobely, cmap = 'gray')
plt.title('Sobel Y'), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 3), plt.imshow(laplacian, cmap = 'gray')
plt.title("LoG"), plt.xticks([]), plt.yticks([])
plt.subplot(2,2, 4), plt.imshow(img, cmap = 'gray')
plt.title("Gaussian Blur"), plt.xticks([]), plt.yticks([])
plt.plot(2,2,1), plt.imshow(median, cmap = 'gray')
plt.title("Median"), plt.xticks([]), plt.yticks([])
plt.show()

#3-1
Z = cv2.imread('zebra-giraffe.jpg', cv2.IMREAD_COLOR)
ZG =cv2.cvtColor(Z, cv2.COLOR_BGR2GRAY)
cv2_imshow(ZG)

#3-2
snp = (np.copy(ZG))
rate = .25
num_s = np.ceil(rate * ZG.size)
coords = [np.random.randint(0,i-1,int(num_s))
       for i in ZG.shape]
snp[coords] = 0
#Pepper
num_p = np.ceil(rate * ZG.size)
coords = [np.random.randint(0,i-1,int(num_p))
       for i in ZG.shape]
snp[coords] = 1
cv2_imshow(snp)

#Magnitude Spectrum
img_float32 = np.float32(snp)
dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)
dft_shift = np.fft.fftshift(dft)
magnitude_spectrum = 20*np.log(cv2.magnitude(dft_shift[:,:,0],dft_shift[:,:,1]))
plt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')
plt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])
plt.show()

dft = np.fft.fft2(snp)
dft_shift = np.fft.fftshift(dft)
phase_spectrum = np.angle(dft_shift)


ax2 = plt.subplot(1,2,2)
ax2.imshow(phase_spectrum, cmap='gray')
plt.title('D-FFT Phase'), plt.xticks([]), plt.yticks([])
plt.show()

# Load the image
img = cv2.imread('zebra-giraffe.jpg')

# Convert the image to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Compute the 2D FFT of the image
fft = np.fft.fft2(gray)

# Shift the zero-frequency component of the FFT to the center
fft_shift = np.fft.fftshift(fft)

# Compute the magnitude spectrum of the FFT
mag_spectrum = np.abs(fft_shift)

# Define the filter using rectangles
a = np.random.uniform(0.1, 0.5)
b = np.random.uniform(a, 0.9)
x_max, y_max = gray.shape[::-1]
filter_rect = np.zeros_like(mag_spectrum)
filter_rect[int(y_max*(1-a)/2):int(y_max*(1+a)/2), int(x_max*(1-b)/2):int(x_max*(1+b)/2)] = 1
filter_rect[int(y_max*(1-b)/2):int(y_max*(1+b)/2), int(x_max*(1-a)/2):int(x_max*(1+a)/2)] = 1

# Apply the filter to the magnitude spectrum
filtered_spectrum = mag_spectrum * filter_rect

# Shift the zero-frequency component of the filtered spectrum back to the corner
filtered_shift = np.fft.ifftshift(filtered_spectrum)

# Reconstruct the filtered image using the inverse FFT
filtered_image = np.fft.ifft2(filtered_shift).real

# Normalize the filtered image to 0-255 range
filtered_image = cv2.normalize(filtered_image, None, 0, 255, cv2.NORM_MINMAX)

# Convert the image to 8-bit unsigned integer
filtered_image = filtered_image.astype(np.uint8)

# Display the original and filtered images
#cv2_imshow( gray)
cv2_imshow( filtered_image)
cv2.waitKey(0)
cv2.destroyAllWindows()

#1st image of 3-5
Z = cv2.imread('zebra-giraffe.jpg', cv2.IMREAD_COLOR)
img =cv2.cvtColor(Z, cv2.COLOR_BGR2GRAY)
dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)

dft_shift = np.fft.fftshift(dft)

##Magnitude of the function is 20.log(abs(f))
magnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]+ 1e-9))

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)

mask = np.ones((rows, cols, 2), np.uint8)
r = 80
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 0


rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r = 100
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 1
# Band Pass Filter - Concentric circle mask, only the points living in concentric circle are ones
rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r_out = 300
r_in = 100
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = np.logical_and(((x - center[0]) ** 2 + (y - center[1]) ** 2 >= r_in ** 2),
                           ((x - center[0]) ** 2 + (y - center[1]) ** 2 <= r_out ** 2))
mask[mask_area] = 1

# apply mask and inverse DFT
fshift = dft_shift * mask

fshift_mask_mag = 2000 * np.log(cv2.magnitude(fshift[:, :, 0], fshift[:, :, 1]+ 1e-9))

f_ishift = np.fft.ifftshift(fshift)
img_back = cv2.idft(f_ishift)
img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
fig = plt.figure(figsize=(12, 12))
ax3 = fig.add_subplot(2,2,3)
ax3.imshow(fshift_mask_mag, cmap='gray')
ax3.title.set_text('FFT + Mask')

plt.show()

#2nd image for 3-5
Z = cv2.imread('zebra-giraffe.jpg', cv2.IMREAD_COLOR)
img =cv2.cvtColor(Z, cv2.COLOR_BGR2GRAY)
dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)

dft_shift = np.fft.fftshift(dft)

magnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]+ 1e-9))

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)

mask = np.ones((rows, cols, 2), np.uint8)
r = 80
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 0


rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r = 100
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 1

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r_out = 200
r_in = 0
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = np.logical_and(((x - center[0]) ** 2 + (y - center[1]) ** 2 >= r_in ** 2),
                           ((x - center[0]) ** 2 + (y - center[1]) ** 2 <= r_out ** 2))
mask[mask_area] = 1

fshift = dft_shift * mask

fshift_mask_mag = 2000 * np.log(cv2.magnitude(fshift[:, :, 0], fshift[:, :, 1]+ 1e-9))

f_ishift = np.fft.ifftshift(fshift)
img_back = cv2.idft(f_ishift)
img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
fig = plt.figure(figsize=(12, 12))
ax3 = fig.add_subplot(2,2,3)
ax3.imshow(fshift_mask_mag, cmap='gray')
ax3.title.set_text('FFT + Mask')

plt.show()

#3rd image for 3-5
Z = cv2.imread('zebra-giraffe.jpg', cv2.IMREAD_COLOR)
img =cv2.cvtColor(Z, cv2.COLOR_BGR2GRAY)
#cv2_imshow(ZG)
dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)

dft_shift = np.fft.fftshift(dft)

magnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]+ 1e-9))

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)

mask = np.ones((rows, cols, 2), np.uint8)
r = 80
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 0

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r = 100
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 1

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r_out = 700
r_in = 80
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = np.logical_and(((x - center[0]) ** 2 + (y - center[1]) ** 2 >= r_in ** 2),
                           ((x - center[0]) ** 2 + (y - center[1]) ** 2 <= r_out ** 2))
mask[mask_area] = 1

fshift = dft_shift * mask

fshift_mask_mag = 2000 * np.log(cv2.magnitude(fshift[:, :, 0], fshift[:, :, 1]+ 1e-9))

f_ishift = np.fft.ifftshift(fshift)
img_back = cv2.idft(f_ishift)
img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
fig = plt.figure(figsize=(12, 12))
ax3 = fig.add_subplot(2,2,3)
ax3.imshow(fshift_mask_mag, cmap='gray')
ax3.title.set_text('FFT + Mask')

plt.show()

#3-4
Z = cv2.imread('zebra-giraffe.jpg', cv2.IMREAD_COLOR)
img =cv2.cvtColor(Z, cv2.COLOR_BGR2GRAY)
dft = cv2.dft(np.float32(img), flags=cv2.DFT_COMPLEX_OUTPUT)

dft_shift = np.fft.fftshift(dft)

##Magnitude of the function is 20.log(abs(f))
magnitude_spectrum = 20 * np.log(cv2.magnitude(dft_shift[:, :, 0], dft_shift[:, :, 1]+ 1e-9))

rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)

mask = np.ones((rows, cols, 2), np.uint8)
r = 80
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 0


rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r = 100
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = (x - center[0]) ** 2 + (y - center[1]) ** 2 <= r*r
mask[mask_area] = 1
# Band Pass Filter - Concentric circle mask, only the points living in concentric circle are ones
rows, cols = img.shape
crow, ccol = int(rows / 2), int(cols / 2)
mask = np.zeros((rows, cols, 2), np.uint8)
r_out = 300
r_in = 0
center = [crow, ccol]
x, y = np.ogrid[:rows, :cols]
mask_area = np.logical_and(((x - center[0]) ** 2 + (y - center[1]) ** 2 >= r_in ** 2),
                           ((x - center[0]) * 0 + (y - center[1]) ** 2 <= r_out ** 2))
mask[mask_area] = 1

# apply mask and inverse DFT
fshift = dft_shift * mask

fshift_mask_mag = 2000 * np.log(cv2.magnitude(fshift[:, :, 0], fshift[:, :, 1]+ 1e-9))

f_ishift = np.fft.ifftshift(fshift)
img_back = cv2.idft(f_ishift)
img_back = cv2.magnitude(img_back[:, :, 0], img_back[:, :, 1])
fig = plt.figure(figsize=(12, 12))
ax3 = fig.add_subplot(2,2,3)
ax3.imshow(fshift_mask_mag, cmap='gray')
ax3.title.set_text('FFT + Mask')

plt.show()